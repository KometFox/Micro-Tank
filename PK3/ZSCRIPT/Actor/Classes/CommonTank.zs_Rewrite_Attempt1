// Blocker object for the front and back of the tank used to keep actors from walking inside the model
class TankBlocker : Actor
{
	Vector3 spawnoffset;
	Vector3 offset;
	double oldpitch;
	double oldroll;
	double oldangle;

	Default
	{
		+CANPASS
		+NOGRAVITY
		+SOLID
		+SHOOTABLE
		+NOBLOOD
		+NODAMAGE
		+NOTAUTOAIMED
		+DONTTHRUST
		Painchance 255;
		Radius 32;
		Height 64;
	}
	States
	{
		Spawn:
			TNT1 A -1;
			Stop;
	}

	override void PostBeginPlay()
	{
		if (scale.x == 1.0 && scale.y == 1.0)
		{
			scale.x = Radius * 2; 
			scale.y = Height;
		}

		if (master)
		{
			spawnoffset = pos - master.pos;

			Vector2 temp = RotateVector((spawnoffset.x, spawnoffset.y), -master.angle);
			spawnoffset = (temp.x, temp.y, spawnoffset.z);

			offset = spawnoffset;
		}
	}

	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		if (master && master.master) // Ugh...
		{
			if (source != master.master)
			{
				master.master.DamageMobj(inflictor, source, damage, mod, flags, angle);  // Inflict the damage on the owner of the tank
			}
		}

		return Super.DamageMobj(inflictor, source, damage, mod, flags, angle);
	}

	override bool Used(Actor user)
	{
		if (master) { return master.Used(user); }
		return false;
	}

	override bool CanCollideWith(Actor other, bool passive)
	{
		if (master && master.master && other != master && other != master.master && !master.master.IsFriend(other))
		{
			other.DamageMobj(self, master.master, int(master.master.vel.length() * 0.625), "Trample");

			return master.CanCollideWith(other, passive);
		}

		return Super.CanCollideWith(other, passive);
	}


	override void Tick()
	{
		Super.Tick();

		if (master)
		{
			scale.x *= master.scale.x;
			scale.y *= master.scale.y;

			SetTag(master.GetTag());

			Species = master.Species;
		}

		Rotate();
	}

	void Rotate()
	{
		Vector2 temp;

		// Keep the blocks in the correct position, regardless of pitch/roll of the master actor
		// Obviously not perfect, because the blocks are square, but close enough when you can't see them.
		if (master && spawnoffset != (0, 0, 0)) {
			temp = RotateVector((spawnoffset.y, spawnoffset.z), master.roll);
			offset = (spawnoffset.x, temp.x, temp.y);

			temp = RotateVector((offset.x, offset.z), 360 - master.pitch);
			offset = (temp.x, offset.y, temp.y);

			temp = RotateVector((offset.x, offset.y), master.angle);
			offset = (temp.x, temp.y, offset.z);

			offset.x *= master.scale.x;
			offset.y *= master.scale.x;
			offset.z *= master.scale.y;

			SetOrigin(master.pos + offset, true);

			angle = master.angle;

			oldpitch = master.pitch;
			oldroll = master.roll;
			oldangle = master.angle;
		}
	}
}

// Target for tanks to aim at
class TankInterceptTarget : Actor
{
	Default
	{
		+BRIGHT
		+INVISIBLE
		+NOINTERACTION
		Alpha 0.5;
		RenderStyle "Translucent";
	}

	States
	{
	Spawn:
		EXCL A -1;
		Stop;
	}

	override void Tick()
	{
		Super.Tick();
		if (developer >= 1)
		{
			bInvisible = false;
		}
		else
		{
			bInvisible = true;
		}
	}
}


class TankBase : VehicleBase
{
	Actor ally, treads, turret, gun, gunspot, frontgunspot;
	Class<Actor> body;
	Class<Actor> TurretProjectile;
	Class<Actor> FrontGunProjectile;
	double minpitch, maxpitch, minp, maxp;
	int missilecount, missiletimeout, bulletcount, bullettimeout, chasetimeout, turrettimeout, reversetimeout, targettimeout, turretdelay;
	sound movesound, idlesound;
	bool missiletargeted, wheeled;
	double zoffset, turretanglerange, turretspeed;
	bool user_static;
	bool intercept;
	Actor InterceptTarget; // Target for tank to aim at
	
	Property TankActor:body;
	Property MoveSound:movesound;
	Property IdleSound:idlesound;
	Property TurretAngleRange:turretanglerange;
	Property TurretSpeed:turretspeed;
	Property WheeledMovement:wheeled;
	Property MaxGunPitch:maxpitch;
	Property MinGunPitch:minpitch;
	Property TurretProjectile:TurretProjectile;
	Property FrontGunProjectile:FrontGunProjectile;
	Property TurretDelay:turretdelay;

	Default
	{
		MaxDropoffHeight 24;
		MaxStepHeight 24;
		Height 20;
		Radius 16;
		Mass 0x7ffffff;
		BloodType "TankSpark";
		DamageFactor "Melee", 0.0;	// Knife, boot, etc.
		DamageFactor "Bullet", 0.125;	// Most guns
		DamageFactor "Pellet", 0.125;	// Shotguns
		DamageFactor "Rifle", 0.5;	// Kar98, sniper rifle, chaingun
		DamageFactor "Fire", 0.5;	// Flamer
		DamageFactor "Trample", 0.1;	// Collision with another Tank/Vehicle
		Monster;

		Obituary "$TANKGUN";
		Species "NaziTank";
		MaxTargetRange 2048;
		RenderStyle "None";
		+AVOIDMELEE
		+BOSS
		+BOSSDEATH
		+DONTMORPH
		+FLOORCLIP
		+ISMONSTER
		+LOOKALLAROUND
		+NOBLOOD
		+NOBLOODDECALS
		+NODROPOFF
		+NOINFIGHTING
		+PAINLESS
		+SLIDESONWALLS
		+SOLID
		TankBase.TankActor "US_Sherman";
		TankBase.MoveSound "TKMOVE";
		TankBase.IdleSound "TKIDLE";
		TankBase.MinGunPitch -10;
		TankBase.MaxGunPitch 25;
		TankBase.TurretSpeed 1.5;
		TankBase.TurretProjectile "Rocket";
		//TankBase.TurretProjectile "TankMissile";
		TankBase.FrontGunProjectile "PlasmaBall";
		//TankBase.FrontGunProjectile "EnemyChaingunTracer";
		TankBase.TurretDelay 9;
	}

	States
	{
		Spawn:
			MDLA A 35 {
				target = FindEnemy();
				if (target) { SetStateLabel("See"); }
			}
			Loop;
		See:
			TNT1 A 1 A_TankChase();
			Goto See;
		Death:
			TNT1 A -1 DoDeath();
			Stop;
	}

	override void PostBeginPlay()
	{
		//A_GiveInventory("Z_DontShadeMe");

		// Spawn everything in neutral orientation
		pitch = 0;
		roll = 0;

		if (bFriendly) { Species = "AllyTank"; }
		else { Species = "NaziTank"; }

		bool sp;
		while (!treads) { [sp, treads] = A_SpawnItemEx(body, 0, 0, 0, 0, 0, 0, 0, SXF_TRANSFERPITCH | SXF_TRANSFERROLL | SXF_TRANSFERSCALE); }
		treads.master = self;
		treads.bSolid = false;
		treads.Species = Species;
		treads.bFriendly = bFriendly;

		if (!user_static) { A_StartSound(idlesound, CHAN_6, CHANF_LOOPING, 0.25); }
		else { level.total_monsters--; }

		targettimeout = Random(0, 35);
		// Disable intercepting missiles on lower skill levels
		intercept = G_SkillPropertyInt(SKILLP_ACSReturn) > 2;
		InterceptTarget = Spawn("TankInterceptTarget", Pos, ALLOW_REPLACE);

		Super.PostBeginPlay();
	}

	void DoDeath()
	{
		if (turret) { turret.Destroy(); }
		InterceptTarget.Destroy();

		A_StopSound(CHAN_6); //the idle sound
		A_StopSound(CHAN_7);
		A_StartSound("weapons/explode", CHAN_AUTO, 0, 1.0, ATTN_IDLE);
		A_Scream();
		A_NoBlocking();

		if (treads)
		{
			Actor hulk = Spawn(TankTreadsBase(treads).deadclass, pos);

			hulk.angle = treads.angle;
			hulk.pitch = treads.pitch;
			hulk.roll = treads.roll;

			for (int i = 0; i < 30; i++)
			{
				A_SpawnItemEx(TankTreadsBase(treads).debris, random(88, 96), random(88, 96), random(88, 112), random(1, 3), random(1, 3), random(1, 3), random(0, 360), SXF_CLIENTSIDE);
				//A_SpawnItemEx("Debris_GlassShard_Large", random(88, 96), random(88, 96), random(96, 128), random(1, 3), random(1, 3), random(1, 3), random(0, 360), SXF_CLIENTSIDE);
			}
		}

		A_RemoveChildren(true, RMVF_EVERYTHING);
		
		//A_SpawnItemEx("Nuke", 0, 0, 5, 0, 0, 0, 0, SXF_TRANSFERPOINTERS|SXF_NOCHECKPOSITION);
		//A_SpawnItemEx("KaBoomer", 0, 0, 0, 0, 0, 0, 0, SXF_TRANSFERPOINTERS);
		//A_SpawnItemEx("GeneralExplosion_Large", 56, 0, 32);
	}

	override void Tick()
	{
		Actor.Tick();

		if (globalfreeze || level.Frozen || user_static) { return; }

		if (missiletimeout > 0) { missiletimeout--; }
		if (bullettimeout > 0) { bullettimeout--; }
		if (chasetimeout > 0) { chasetimeout--; }
		if (turrettimeout > 0) { turrettimeout--; }
		if (reversetimeout > 0) { reversetimeout--; }
		if (targettimeout > 0) { targettimeout--; }

		if (!turret)
		{
			if (TankTreadsBase(treads))
			{
				turret = TankTreadsBase(treads).turret;

				if (turret)
				{
					turret.master = self;
					turret.angle = angle;
					turret.bSolid = false;
					turret.Species = Species;
				}
			}
		}

		if (treads && turret)
		{
			double zoffset = VehicleBase.SetPitchRoll(treads);
			double newz = pos.z - zoffset > GetZAt(0, 0) + MaxDropoffHeight ? pos.z - zoffset : GetZAt(0, 0);
			treads.SetOrigin((pos.xy, newz), true);

			double delta = deltaangle(treads.angle, turret.angle);

			minp = treads.pitch * cos(delta) - maxpitch;
			maxp = treads.pitch * cos(delta) - minpitch;

			turret.SetOrigin(treads.pos + (RotateVector((treads.radius * sin(treads.pitch), -treads.radius * sin(treads.roll)), treads.angle), treads.height * cos(treads.roll)), true);

			turret.pitch = treads.roll * sin(-delta) + treads.pitch * cos(delta);
			turret.roll = treads.roll * cos(-delta) + treads.pitch * sin(delta);

			if (!gun) { gun = TankTurretBase(turret).gun; }

			if (gun)
			{
				gun.A_Face(target, 0, turretspeed, flags:FAF_MIDDLE);

				// Force pitch clamping
				if (turret.pitch + gun.pitch >= maxp) { gun.pitch = maxp; }
				else if (turret.pitch + gun.pitch < minp)  { gun.pitch = minp; }

				gun.roll = turret.roll;
			}

			if (!gunspot) { gunspot = TankTurretBase(turret).gunspot; }
		}

		if (!frontgunspot) { frontgunspot = TankTreadsBase(treads).gunspot; }

		//if (bFriendly && (!ally || ally.health <= 0)) { ally = FindClosestPlayer(self, 360, 0, false); }

		if (target && bAvoidMelee) { bFrightened = Distance2D(target) < 256; } // Keep distance from the target
	}

	override bool CanCollideWith(Actor other, bool passive)
	{
		if (IsFriend(other) || (other is "TankBlocker" && other.Species == Species)) { return false; }

		if (!treads || (other.pos.z + height > treads.pos.z && other.pos.z < treads.pos.z + treads.height))
		{
			other.DamageMobj(self, self, int(vel.length() * 0.625), "Trample");
		}

		return Super.CanCollideWith(other, passive);
	}

	Actor FindEnemy()
	{
		Actor enemy = null;

		if (bFriendly)
		{
			if (ally && ally.player.attacker && ally.player.attacker != ally && ally.player.attacker.health > 0)
			{
				if (Distance3D(ally.player.attacker) < MaxTargetRange) { enemy = ally.player.attacker; }
			}
		}
		else
		{
			for (int p = 0; p < MAXPLAYERS; p++)
			{ // Iterate through all of the players and find the closest one
				Actor pl = players[p].mo;

				if (pl)
				{
					if (!pl.bShootable || pl.health <= 0) { continue; }
					if (players[p].cheats & CF_NOTARGET) { continue; }
					if (isFriend(pl)) { continue; }
					if (Distance3D(pl) > MaxTargetRange) { continue; }
					if (enemy && Distance3d(pl) > Distance3d(enemy)) { continue; }

					enemy = pl;
				}
			}
		}

		ThinkerIterator Finder;
		//Base mo;
		Actor mo;

		// Only target sneakable actors if you are a friendly tank (so that enemy tanks won't target sneakable enemies)
		/*
		if (bFriendly)
		{
			Finder = ThinkerIterator.Create("Base", STAT_DEFAULT - 5);

			while ( (mo = Base(Finder.Next())) )
			{
				if (!IsValidTarget(mo)) { continue; }
				if (enemy && Distance3d(mo) > Distance3d(enemy)) { continue; }

				enemy = mo;
			}
		}
		*/

		// A Second iterator to account for the non-sneakables...
		//Finder = ThinkerIterator.Create("Base", STAT_DEFAULT);
		Finder = ThinkerIterator.Create("MT_Actor", STAT_DEFAULT);

		/*
		while ( (mo = Base(Finder.Next())) )
		{
			if (!IsValidTarget(mo)) { continue; }
			if (enemy && Distance3d(mo) > Distance3d(enemy)) { continue; }

			enemy = mo;
		}
		*/

		// A third iterator to account for the player followers...
		/*
		Finder = ThinkerIterator.Create("PlayerFollower", STAT_DEFAULT);
		PlayerFollower pf;

		while ( (pf = PlayerFollower(Finder.Next())) )
		{
			if (!IsValidTarget(pf)) { continue; }
			if (enemy && Distance3d(pf) > Distance3d(enemy)) { continue; }

			enemy = pf;
		}
		*/

		return enemy;
	}

	bool IsValidTarget(Actor mo)
	{
		if (mo is "TankBase" && TankBase(mo).treads) { mo = TankBase(mo).treads; }

		if (
			!mo.bIsMonster ||
			mo.health <= 0 ||
			mo.bDormant ||
			!IsHostile(mo) ||
			mo == self ||
			!CheckSight(mo) ||
			Distance3D(mo) > MaxTargetRange //|| 
			//mo is "StatistBarkeeper" || // Ignore NPCs...
			//mo is "Camp_PrisonerBald" || // Ignore Camp Prisoners...
			//(!bFriendly && Nazi(mo) && Nazi(mo).user_sneakable) // Ignore sneakables who are set via editor property
		) { return false; }

		return true;
	}

	virtual void A_TankChase(int flags = 0)
	{
		if (!treads || user_static) { return; }

		if (bStandStill) { flags |= CHF_DONTMOVE | CHF_DONTTURN; }

		if (!targettimeout && (!target || target.health <= 0 || !CheckLOF(CLOFF_JUMPENEMY | CLOFF_SKIPOBJECT, maxtargetrange) || !IsValidTarget(target))) { target = FindEnemy(); targettimeout = 70; }

		if ((!chasetimeout || !wheeled) && !(flags & CHF_DONTTURN))
		{
			double diff = deltaangle(treads.angle, angle);

			double turnamt = speed / (wheeled ? 3 : 5);

			if (reversetimeout) { turnamt *= -1; }

			if (abs(diff) > abs(turnamt) + 2)
			{
				if (diff < turnamt)
				{
					treads.angle -= turnamt;
					flags |= CHF_DONTMOVE;
					if (InStateSequence(treads.CurState, treads.SpawnState) && treads.FindState("Move")) { treads.SetStateLabel("Move"); }
				}
				else if (diff > -turnamt)
				{
					treads.angle += turnamt;
					flags |= CHF_DONTMOVE;
					if (InStateSequence(treads.CurState, treads.SpawnState) && treads.FindState("Move")) { treads.SetStateLabel("Move"); }
				}
				else
				{
					treads.angle = angle;
				}
			}

			if (wheeled) { DoMove(); }
		}

		if (!target || !CheckLOF(CLOFF_JUMPENEMY | CLOFF_SKIPOBJECT, maxtargetrange, offsetforward: treads.radius))
		{
			missiletimeout = 70;
			bullettimeout = 35;
		}

		Actor cannon = gunspot ? gunspot : (gun ? gun : turret);
		if (turret && !missiletimeout && !turrettimeout && missiletargeted && CheckLOF(CLOFF_JUMPENEMY | CLOFF_SKIPOBJECT, maxtargetrange, offsetforward: treads.radius))
		{
			flags |= CHF_DONTMOVE | CHF_DONTTURN;

			DoTurret(cannon);
			missiletargeted = false;
		}

		if (turret && !turrettimeout)
		{
			if (target)
			{
				Actor aimAt = target;
				if (intercept)
				{
					double interceptTime;
					//interceptTime = ZScriptTools.GetInterceptTime4(Pos, Target.Pos, Target.Vel, GetDefaultSpeed(TurretProjectile));
					interceptTime += turretdelay; // Account for pre-fire delay
					Vector3 interceptPos = Target.Pos + Target.Vel * interceptTime;
					InterceptTarget.SetOrigin(interceptPos, true);
					aimAt = InterceptTarget;
				}
				if (turretanglerange > 0)
				{
					double delta = deltaangle(treads.angle, treads.AngleTo(aimAt));

					if (abs(delta) <= turretanglerange) { turret.A_Face(aimAt, turretspeed); A_StartSound("MACHINE_LOOP_3", 8, CHANF_NOSTOP, 1.0); }
					else { turret.angle = clamp(turret.angle, treads.angle - turretanglerange, treads.angle + turretanglerange); A_StartSound("MACHINE_LOOP_3", 8, CHANF_NOSTOP, 1.0); }
				}
				else { turret.A_Face(aimAt, turretspeed); }

				if (int(turret.angle) == int(turret.AngleTo(aimAt)))
				{
					A_StopSound(8);
					if (CheckLOF(CLOFF_JUMPENEMY | CLOFF_SKIPOBJECT, maxtargetrange, offsetforward: treads.radius) && (!gun || (gun.pitch - turret.pitch >= minp && gun.pitch - turret.pitch <= maxp)))
					{
						DoTurretTarget(cannon);
					}
				}
			}
			else
			{
				turret.angle = clamp(treads.angle, turret.angle - turretspeed, turret.angle + turretspeed);
			}
		}

		if (!bullettimeout && frontgunspot && abs(deltaangle(frontgunspot.angle, frontgunspot.AngleTo(target))) <= 5 && CheckLOF(CLOFF_JUMPENEMY | CLOFF_MUSTBESOLID, maxtargetrange * 2 / 3, offsetforward: Radius * 2))
		{
			DoFrontWeapon(frontgunspot ? frontgunspot : treads);
		}

		if (chasetimeout)
		{
			flags |= CHF_DONTMOVE | CHF_DONTTURN;
			A_StopSound(CHAN_7);
		}
		else if (!bStandStill)
		{
			DoMove();
		}

		A_Chase(null, null, flags);
	}

	void DoMove()
	{
		if (!treads) { return; }

		if (reversetimeout <= 0 && speed != default.speed) { speed = Default.speed; }

		if (!CheckPosition(pos.xy + RotateVector((reversetimeout ? -32 : 32, 0), treads.angle)))
		{
			if (wheeled || !BlockingMobj)
			{
				speed *= -0.5;
				if (speed < 0) { reversetimeout = int((15 + Random(0, 35)) * Default.Speed); }
				else { reversetimeout = 0; }
			}
		}

		A_ChangeVelocity(cos(treads.angle) * speed, sin(treads.angle) * speed, vel.z, CVF_REPLACE);

		if (InStateSequence(treads.CurState, treads.SpawnState) && treads.FindState("Move"))
		{
			 treads.SetStateLabel("Move");
		}

		DoTrample(true);

		A_StartSound(movesound, CHAN_7, CHANF_LOOPING, 1.0);
	}

	// Fire the main cannon at the target. The main cannon is assumed to be
	// already aiming at its target.
	// origin - The main cannon actor
	virtual void DoTurret(Actor origin)
	{
		missiletargeted = false;
		bullettimeout = 20;
		turrettimeout = 40;
		chasetimeout = 5;
	}

	// Fire the turret at the target. The turret is not assumed to be aiming at
	// its target, so you will need to make the turret aim at the target when.
	// you override this method.
	// origin - The turret actor
	virtual void DoTurretTarget(Actor origin)
	{
		missiletargeted = true;
		chasetimeout = 40;
		turrettimeout = turretdelay;
	}

	// Fire the front weapon at the target. The front weapon is assumed to be
	// aiming at the target.
	// origin - The front weapon
	virtual void DoFrontWeapon(Actor origin)
	{
		chasetimeout = 20;
		missiletimeout = 70;
	}

	override String GetObituary(Actor victim, Actor inflictor, Name mod, bool playerattack)
	{
		if (mod == 'Trample')
		{
			return "$TRAMPLE";
		}
		else if (mod == 'Rocket')
		{
			return "$TANKSHELL";
		}

		return Super.GetObituary(victim, inflictor, mod, playerattack);
	}

	override void OnDestroy()
	{
		if (user_static) { level.total_monsters++; }

		Super.OnDestroy();
	}
}

// Vehicle base class - handles trample effect and slope aware terrain following
class VehicleBase : MT_Actor
{
	double trampleradius;

	Property TrampleRadius:trampleradius;

	Default
	{
		VehicleBase.TrampleRadius -1;
	}

	// Handling for terrain-based pitch/roll calculations...
	static double SetPitchRoll(Actor mo, double xoffset = 0, double yoffset = 0, int cap = 80, bool force = false, double centerxoffset = 0, double centeryoffset = 0)
	{
		if (!mo) { return 0; }

		double testwidth = mo.radius + yoffset;
		double testlength;

		if (mo is "TankTreadsBase") { testlength = TankTreadsBase(mo).length; }
		if (!testlength) { testlength = mo.radius + xoffset; }

		// Account for current pitch/roll when measuring corner heights
		testwidth *= abs(cos(mo.roll));
		testlength *= abs(cos(mo.pitch));

		double points[4], minz = 0x7FFFFFFF, maxz = -0x7FFFFFFF;

		// Get the relative z-height at the four corners of the tank
		points[0] = mo.GetZAt(centerxoffset + testlength, centeryoffset + testwidth);
		points[1] = mo.GetZAt(centerxoffset + testlength, centeryoffset - testwidth);
		points[2] = mo.GetZAt(centerxoffset - testlength, centeryoffset + testwidth);
		points[3] = mo.GetZAt(centerxoffset - testlength, centeryoffset - testwidth);

		for (int i = 0; i < 4; i++)
		{
			double maxstep = mo.master ? mo.master.MaxStepHeight : mo.MaxStepHeight;
			double maxdrop = mo.master ? mo.master.MaxDropoffHeight : mo.MaxDropoffHeight;

			if (points[i] > mo.pos.z + maxstep) { points[i] = 0; } // Ignore the point if you can't climb that high
			else if (points[i] < mo.pos.z - maxdrop) { points[i] = 0; } // Ignore the point if it's a dropoff
			else { points[i] -= mo.floorz; }
		}

		// Use those values to calculate the pitch.roll amounts
		double pitchinput = (points[0] + points[1]) / 2 - (points[2] + points[3]) / 2;
		double rollinput = (points[1] + points[3]) / 2 - (points[0] + points[2]) / 2;

		pitchinput = atan(pitchinput / (testlength * 2));
		rollinput = atan(rollinput / (testwidth * 2));

		// Interpolate to the new values
		if (force || level.time && level.time < 15)
		{
			mo.pitch = clamp(-pitchinput, -cap, cap);
			mo.roll = clamp(rollinput, -cap, cap);
		}
		else
		{
			if (mo.pitch > -pitchinput) { mo.pitch = max(mo.pitch - 1, -pitchinput); }
			if (mo.pitch < -pitchinput) { mo.pitch = min(mo.pitch + 1, -pitchinput); }

			if (mo.roll > rollinput) { mo.roll = max(mo.roll - 1, rollinput); }
			if (mo.roll < rollinput) { mo.roll = min(mo.roll + 1, rollinput); }

			mo.pitch = clamp(mo.pitch, -cap, cap);
			mo.roll = clamp(mo.roll, -cap, cap);
		}


		if (mo.master)
		{
			// Return the amount that you need to adjust the model z position by in order to keep it looking like it's actually on the ground
			double deltaz = testlength * sin(abs(mo.pitch)) + testwidth * sin(abs(mo.roll));

			return deltaz; 
		}

		return 0;
	}

	override bool CanCollideWith(Actor other, bool passive)
	{
		//if (other is "FlattenableProp") { return false; }
		//if (other is "Trample") { return false; }
		return true;
	}

	override void Tick()
	{
		SetPitchRoll(self);
		DoTrample();

		Actor.Tick();
	}

	void DoTrample(bool always = false)
	{
		double movespeed = vel.length();

		if (trampleradius == -1)
		{
			if (self is "TankBase" && TankTreadsBase(TankBase(self).treads))
			{
				trampleradius = TankBase(self).treads.radius;
			}
			else { trampleradius = radius; }
		}

		if (movespeed >= 1 || always)
		{
			double dmg = always ? 1 : movespeed * 0.625;
			let treads = TankTreadsBase(TankBase(self).treads);

			bool sp;
			Actor t;

			// The explosion should only stick out 16 units in front of the tank
			double offset = trampleradius - radius + 16;
			if (self is "TankBase" && treads) { offset = max(treads.length, radius) - trampleradius + 16; }

			double angleoffset = treads ? treads.angle : 0;

			[sp, t] = A_SpawnItemEx("Trample", offset, 0, 0, 0, 0, 0, angleoffset, SXF_TRANSFERPITCH | SXF_TRANSFERROLL | SXF_TRANSFERSCALE | SXF_ABSOLUTEANGLE);

			if (t)
			{
				t.target = self; // Set the vehicle as the Trample actor's target, because Trample uses A_Explode, which defaults to treating the actor's target as the originator (and doesn't damage it)
				t.A_SetSize(trampleradius, Height / 3);
				Trample(t).dmg = int(dmg);
				if (treads) { t.angle = treads.angle; }
			}
		}
	}
}

// Trample actor - basically an explosion that simulates the spawning actor running over actors within its radius
// Used by tanks and by rail sequences
class Trample : MT_Actor
{
	int dmg;
	int flags;

	Default
	{
		DamageType "Trample";
		Damage 5;
		Height 56;
		Radius 56;
		+NOBLOCKMAP
		+NOGRAVITY
		+NOCLIP
	}

	States
	{
		Spawn:
			TNT1 A 0;
		Death:
			"####" # 20 {
				A_Explode(dmg == 0 ? damage : dmg, int(Radius), flags, FALSE, int(Radius));
			}
			Stop;
	}
}


class ActorPositionable : Actor
{
	enum RotationFlags
	{
		ROT_MatchAngle = 1,
		ROT_MatchPitch = 2,
		ROT_MatchRoll = 4,
	};

	Vector3 spawnoffset;
	Vector3 offset;

	override void PostBeginPlay()
	{
		if (!master) { Destroy(); return; }

		spawnoffset = pos - master.pos;

		Vector2 temp = RotateVector((spawnoffset.x, spawnoffset.y), -master.angle);
		spawnoffset = (temp.x, temp.y, spawnoffset.z);

		Species = master.Species;

		Super.PostBeginPlay();
	}

	void RotateWithMaster(int flags = ROT_MatchAngle | ROT_MatchPitch | ROT_MatchRoll)
	{
		Vector2 temp;

		// Keep the actor in the correct position, regardless of pitch/roll of the master actor
		if (master)
		{
			if (spawnoffset != (0, 0, 0))
			{
				temp = RotateVector((spawnoffset.y, spawnoffset.z), master.roll);
				offset = (spawnoffset.x, temp.x, temp.y);

				temp = RotateVector((offset.x, offset.z), 360 - master.pitch);
				offset = (temp.x, offset.y, temp.y);

				temp = RotateVector((offset.x, offset.y), master.angle);
				offset = (temp.x, temp.y, offset.z);
			}

			SetOrigin(master.pos + offset, true);

			if (flags & ROT_MatchAngle) { angle = master.angle; }

			double delta = deltaangle(master.angle, angle);

			if (flags & ROT_MatchPitch) { pitch = master.roll * sin(-delta) + master.pitch * cos(delta); }
			if (flags & ROT_MatchRoll) { roll = master.roll * cos(-delta) + master.pitch * sin(delta); }
		}
	}

	override void Tick()
	{
		RotateWithMaster();

		Super.Tick();
	}
}

class WeaponSpot : ActorPositionable
{
	Default
	{
		Height 2;
		Radius 1;
		+NOBLOCKMAP
		+NOGRAVITY
		+NOINTERACTION
		+INVISIBLE
	}

	States
	{
		Spawn:
			AMRK A -1;
			Stop;
	}

	override void PostBeginPlay()
	{
		if (master) { Species = master.Species; }

		Super.PostBeginPlay();
	}
}

// Base actor for tank turret
class TankTurretBase : Actor
{
	Actor gun, gunspot;
	Class<Actor> gunclass;
	Vector3 spawnoffset;
	Vector3 offset;
	double gunoffsetx, gunoffsetz, turretoffsetx;
	Vector3 gunspotoffset;
	double gunspotoffsetx, gunspotoffsety, gunspotoffsetz;

	Property TurretOffsetX:turretoffsetx;
	Property GunClass:gunclass;
	Property GunOffsetX:gunoffsetx;
	Property GunOffsetZ:gunoffsetz;
	Property GunSpotX:gunspotoffsetx;
	Property GunSpotY:gunspotoffsety;
	Property GunSpotZ:gunspotoffsetz;

	Default
	{
		Height 0;
		Species "NaziTank";
		+DONTSPLASH
		+NOGRAVITY
		+SOLID
		TankTurretBase.GunOffsetX 32;
		TankTurretBase.GunOffsetZ 18;
		TankTurretBase.GunSpotX 0;
		TankTurretBase.GunSpotY 0;
		TankTurretBase.GunSpotZ 0;
	}

	States
	{
		Spawn:
			MDLA A -1;
			Stop;
	}

	override void PostBeginPlay()
	{
		bool sp = false;

		if (gunclass)
		{
			while (!gun) { [sp, gun] = A_SpawnItemEx(gunclass, gunoffsetx, 0, gunoffsetz, 0, 0, 0, 0, SXF_TRANSFERPITCH | SXF_TRANSFERROLL | SXF_TRANSFERSCALE); }
			gun.Species = Species;

			spawnoffset = gun.pos - pos;

			spawnoffset = (RotateVector(spawnoffset.xy, -angle), spawnoffset.z);
		}

		gunspotoffset = (gunspotoffsetx, gunspotoffsety, gunspotoffsetz);
		while (!gunspot) { [sp, gunspot] = A_SpawnItemEx("WeaponSpot", gunspotoffset.x, gunspotoffset.y, gunspotoffset.z, 0, 0, 0, 0, SXF_TRANSFERPITCH | SXF_TRANSFERROLL | SXF_TRANSFERSCALE); }
		if (gun) { gunspot.master = gun; }
		else { gunspot.master = self; }

		Super.PostBeginPlay();
	}

	override bool CanCollideWith(Actor other, bool passive)
	{
		if (master && other != master) { master.CanCollideWith(other, passive); }

		return true;
	}

	override void Tick()
	{
		if (gun)
		{
			gun.angle = angle;

			Vector2 temp = RotateVector((spawnoffset.y, spawnoffset.z), roll);
			offset = (spawnoffset.x, temp.x, temp.y);

			temp = RotateVector((offset.x, offset.z), 360 - pitch);
			offset = (temp.x, offset.y, temp.y);

			temp = RotateVector((offset.x, offset.y), angle);
			offset = (temp.x, temp.y, offset.z);

			gun.SetOrigin(self.pos + offset, true);

			gun.bSolid = bSolid;
			gun.bInvisible = bInvisible;
		}

		Actor.Tick();
	}

	override void OnDestroy()
	{
		if (gun) { gun.Destroy(); }
	}
}

class TankCannonBase : Actor
{
	Default
	{
		+DONTSPLASH
		+NOGRAVITY
		Species "Tank";
	}

	States
	{
		Spawn:
			MDLA A -1;
			Stop;
	}
}

class TankDeadBase : Actor
{
	Default
	{
		Radius 88;
		Height 96;
		Mass 0x7ffffff;
		+FLOORCLIP
		+NOBLOOD
		+NOBLOODDECALS
		+NODAMAGE
		+NOTAUTOAIMED
		+SHOOTABLE
		+SOLID
		BloodType "TankSpark";
	}
	
	States
	{
	Spawn:
		MDLA A 12; //A_SpawnProjectile("TankSmoke",58,0,random(0,360),2,random(70,130));
		Loop;
	}
}


// Base actor for tank treads
class TankTreadsBase : Actor
{
	Actor turret, gunspot;
	Class<Actor> turretclass, deadclass, debris;
	Class<PowerMorph> morphpowerup;
	int savedhealth;
	int usetimeout;
	double length;
	Vector3 gunspotoffset;
	double gunspotoffsetx, gunspotoffsety, gunspotoffsetz;

	Property TurretClass:turretclass;
	Property Length:length;
	Property MorphPowerup:morphpowerup;
	Property DeadActor:deadclass;
	Property DebrisActor:debris;
	Property GunSpotX:gunspotoffsetx;
	Property GunSpotY:gunspotoffsety;
	Property GunSpotZ:gunspotoffsetz;

	Default
	{
		Radius 64; // Also used as half-width of model for slope tilt calculations
		Height 64;
		Mass 0x7ffffff;
		Species "NaziTank";
		+CANPASS
		+SOLID
		TankTreadsBase.DeadActor "";
		TankTreadsBase.DebrisActor "";
		//TankTreadsBase.DebrisActor "Debris_Tank";
		TankTreadsBase.Length 96; // Half-length of model for slope calculation
		TankTreadsBase.MorphPowerup "";
		TankTreadsBase.GunSpotX 0;
		TankTreadsBase.GunSpotY 0;
		TankTreadsBase.GunSpotZ 0;
	}

	States
	{
		Spawn:
			MDLA A -1;
			Stop;
		Move:
			MDLA AB 5;
			Goto Spawn;
		Death:
			TNT1 A 1 DoDeath();
			Stop;
	}

	override void PostBeginPlay()
	{
		bool sp = false;

		while (!turret) { [sp, turret] = A_SpawnItemEx(turretclass, 0, 0, 0, 0, 0, 0, 0, SXF_TRANSFERPITCH | SXF_TRANSFERROLL); }
		//while (!turret) { [sp, turret] = A_SpawnItemEx(turretclass, 0, 0, Height, 0, 0, 0, 0, SXF_TRANSFERPITCH | SXF_TRANSFERROLL | SXF_TRANSFERSCALE); }

		double r = radius / 2;

		/*
		A_SpawnItemEx("TankBlocker", length - r, -r, flags: SXF_SETMASTER);
		A_SpawnItemEx("TankBlocker", length - r, r, flags: SXF_SETMASTER);
		A_SpawnItemEx("TankBlocker", -(length - r), -r, flags: SXF_SETMASTER);
		A_SpawnItemEx("TankBlocker", -(length - r), r, flags: SXF_SETMASTER);
		*/

		gunspotoffset = (gunspotoffsetx, gunspotoffsety, gunspotoffsetz);
		while (!gunspot) { [sp, gunspot] = A_SpawnItemEx("WeaponSpot", gunspotoffset.x, gunspotoffset.y, gunspotoffset.z, 0, 0, 0, 0, SXF_TRANSFERPITCH | SXF_TRANSFERROLL | SXF_TRANSFERSCALE); }
		gunspot.master = self;

		//if (morphpowerup) { BoACompass.Add(self, "TANKICO"); }

		Super.PostBeginPlay();
	}

	override void Tick()
	{
		if (usetimeout) { usetimeout--; }

		if (master && master.player)
		{
			double moving = master.player.cmd.forwardmove;

			if (moving != 0)
			{
				double movespeed = master.vel.length();

				int dir = moving > 0 ? 1 : -1; // Trample both forward and backwards, depending on which direction you're moving
				double dmg = movespeed * 0.625; // Top speed gives ~100 damage

				bool sp;
				Actor t;

				[sp, t] = A_SpawnItemEx("Trample", scale.x * 128 * dir, 0, height / 2 - 16, 0, 0, 0, 0, SXF_TRANSFERPITCH | SXF_TRANSFERROLL | SXF_TRANSFERSCALE);

				if (t)
				{
					t.target = master; // Set the player as the Trample actor's target, because it uses A_Explode, which defaults to treating the actor's target as the originator (and doesn't damage it)
					Trample(t).dmg = int(dmg);
				}
			}
		}

		if (turret)
		{
			turret.bSolid = bSolid;
			turret.bInvisible = bInvisible;
		}

		Super.Tick();
	}

	override bool Used(Actor user)
	{
		if (!morphpowerup) { return false; }

		if (usetimeout || bDormant || master && (master.player || master.bIsMonster)) { return false; }

		let p = user.player;

		if (p)
		{
			bSolid = False;

			p.mo.SetOrigin(pos, false);

			if (turret) { p.mo.angle = turret.angle; }
			else { p.mo.angle = angle; }

			p.mo.tracer = self;

			user.GiveInventory(morphpowerup, 1);
			return true;
		}
		return false;
	}

	override bool CanCollideWith(Actor other, bool passive)
	{
		if (master && other != master && !master.IsFriend(other))
		{
			other.DamageMobj(self, master, int(0.5 * master.vel.xy.length()), "Trample");

			return master.CanCollideWith(other, passive);
		}

		return Super.CanCollideWith(other, passive);
	}

	void DoDeath()
	{
		if (turret) { turret.Destroy(); }

		A_StartSound("weapons/explode", CHAN_AUTO, 0, 1.0, ATTN_IDLE);

		Actor dead = Spawn(deadclass, pos);

		dead.angle = angle;
		dead.pitch = pitch;
		dead.roll = roll;

		A_RemoveChildren(true, RMVF_EVERYTHING);

		for (int i = 0; i < 20; i++)
		{
			//A_SpawnItemEx(debris, random(88, 96), random(88, 96), random(88, 112), random(1, 3), random(1, 3), random(1, 3), random(0, 360), SXF_CLIENTSIDE);
			//A_SpawnItemEx("Debris_GlassShard_Large", random(88, 96), random(88, 96), random(96, 128), random(1, 3), random(1, 3), random(1, 3), random(0, 360), SXF_CLIENTSIDE);
		}
		
		//A_SpawnItemEx("Nuke", 0, 0, 5, 0, 0, 0, 0, SXF_TRANSFERPOINTERS|SXF_NOCHECKPOSITION);
		//A_SpawnItemEx("KaBoomer", 0, 0, 0, 0, 0, 0, 0, SXF_TRANSFERPOINTERS);
		//A_SpawnItemEx("GeneralExplosion_Large", 56, 0, 32);
	}		
}

class US_Sherman : TankTreadsBase
{
	Default
	{
		//$Category Models (BoA)/Vehicles
		//$Title Driveable US M4 Sherman Tank
		//$Color 3
		Height 20;
		Radius 16;
		MaxStepHeight 24;
		MaxDropoffHeight 24;
		TankTreadsBase.DeadActor "US_ShermanDead";
		TankTreadsBase.DebrisActor "";
		//TankTreadsBase.DebrisActor "Debris_Tank2";
		TankTreadsBase.MorphPowerup "";
		TankTreadsBase.TurretClass "US_ShermanTurret";
		TankTreadsBase.Length 18; 
		TankTreadsBase.GunSpotX 0;
		TankTreadsBase.GunSpotY 0;
		TankTreadsBase.GunSpotZ 0;

	}
}

class US_ShermanTurret : TankTurretBase
{
	Actor gunspot2;

	Default
	{
		TankTurretBase.GunClass "US_ShermanCannon";
		TankTurretBase.GunSpotX 0;
		TankTurretBase.GunSpotY 0;
		TankTurretBase.GunSpotZ 0;
		TankTurretBase.TurretOffsetX 0;
		Height 20;
		Radius 16;
	}

	override void PostBeginPlay()
	{
		bool sp = false;

		Vector3 gunspot2offset = (0, 0, 0);
		//Vector3 gunspot2offset = (16, 20, 18);
		while (!gunspot2) { [sp, gunspot2] = A_SpawnItemEx("WeaponSpot", gunspot2offset.x, gunspot2offset.y, gunspot2offset.z, 0, 0, 0, 0, SXF_TRANSFERPITCH | SXF_TRANSFERROLL | SXF_TRANSFERSCALE); }
		gunspot2.master = self;

		Super.PostBeginPlay();
	}
}

class US_ShermanCannon : TankCannonBase {}
class US_ShermanDead : TankDeadBase {}


Class BoAFindHitPointTracer : LineTracer
{
	Name skipspecies;
	Actor skipactor;

	override ETraceStatus TraceCallback() // Doesn't handle 3d Floors :-/
	{
		if (Results.HitType == TRACE_HitActor)
		{
			if (
				Results.HitActor != skipactor && // Skip the player
				//!(Results.HitActor is "ShermanPlayer") &&
				(!Results.HitActor.master || Results.HitActor.master != skipactor) && // And any children
				Results.HitActor.species != skipspecies && // And any of the skipped species
				(Results.HitActor.bSolid || Results.HitActor.bShootable) // And only return shootable actors
			) { return TRACE_Continue; } // Fall through, but remember the actor that you hit

			return TRACE_Skip;
		}
		else if (Results.HitType == TRACE_HitFloor || Results.HitType == TRACE_HitCeiling)
		{
			return TRACE_Stop;
		}
		else if (Results.HitType == TRACE_HitWall)
		{
			if (Results.HitLine.flags & (Line.ML_BLOCKING | Line.ML_BLOCKEVERYTHING)) { return TRACE_Stop; }
			if (Results.HitTexture)
			{
				if (Results.Tier != TIER_Middle || Results.HitLine.flags & Line.ML_3DMIDTEX) // 3D Midtex check still isn't perfect...
				{
					return TRACE_Stop;
				}
				return TRACE_Skip;
			}
			return TRACE_Skip;
		}

		return TRACE_Stop;
	}
}


//------------------------------------------------------------------------------
//CHASSIS OBJECT
//------------------------------------------------------------------------------
Class MT_BaseChassis : MT_Actor
{

States
{
	Spawn:
		TNK1 A 0;
		TNK1 A 1;
		loop;
	Death:
		TNT1 A 0;
		stop;
}


}

// Sherman Tank components (used by both FriendlySherman and ShermanPlayer)
class MT_Tank : MT_BaseChassis
{
	Default
	{
		Height 20;
		Radius 16;
		MaxStepHeight 24;
		MaxDropoffHeight 24;
		//TankTreadsBase.DeadActor "US_ShermanDead";
		//TankTreadsBase.DebrisActor "";
		//TankTreadsBase.DebrisActor "Debris_Tank2";
		//TankTreadsBase.MorphPowerup "Sherman";
		//TankTreadsBase.TurretClass "US_ShermanTurret";
		//TankTreadsBase.Length 18; 
		//TankTreadsBase.GunSpotX 0;
		//TankTreadsBase.GunSpotY 0;
		//TankTreadsBase.GunSpotZ 0;
	}
}

//------------------------------------------------------------------------------
//TURRET OBJECT
//------------------------------------------------------------------------------
class MT_TankTurret : TankTurretBase
{
	Actor gunspot2;

	Default
	{
		TankTurretBase.GunClass "US_ShermanCannon";
		TankTurretBase.GunSpotX 0;
		TankTurretBase.GunSpotY 0;
		TankTurretBase.GunSpotZ 0;
		TankTurretBase.TurretOffsetX 0;
		Height 20;
		Radius 16;
	}

	override void PostBeginPlay()
	{
		bool sp = false;

		Vector3 gunspot2offset = (0, 0, 0);
		//Vector3 gunspot2offset = (16, 20, 18);
		while (!gunspot2) { [sp, gunspot2] = A_SpawnItemEx("WeaponSpot", gunspot2offset.x, gunspot2offset.y, gunspot2offset.z, 0, 0, 0, 0, SXF_TRANSFERPITCH | SXF_TRANSFERROLL | SXF_TRANSFERSCALE); }
		gunspot2.master = self;

		Super.PostBeginPlay();
	}
}


//------------------------------------------------------------------------------
//MAIN PLAYER CLASS [CAMERA]
//------------------------------------------------------------------------------
Class MT_BaseTank : PlayerPawn
{
Actor treads, turret, turretcamera, povcamera, gun;
Actor ForcedHealthBar;
Actor Tank_Component, Tank_Turret;
//Class<Actor> Tank_Component;
//Class<Actor> Tank_Turret;
Class<Actor> Chassis;
transient FLineTraceData cameratrace;
BoAFindHitPointTracer hittracer;
double sndvol;
double zoffset;
Vector3 cameralocation;
Vector3 CrosshairPos;
Actor CrosshairActor;
double CrosshairDist;
Property Chassis:chassis;
//Property Tank_Component:Tank_Component;
//Property Tank_Turret:Tank_Turret;
default
{
//	MT_Basetank.Tank_Component "US_Sherman";
//	MT_Basetank.Tank_Turret "US_ShermanTurret";
}

	override void PostBeginPlay()
	{
		bool sp = false;
		
		
		while (!treads) 
		{ 
		[sp, treads] = A_SpawnItemEx(Chassis, 0, 0, 0, 0, 0, 0, 0, SXF_TRANSFERPITCH | SXF_TRANSFERROLL | SXF_TRANSFERSCALE); 
		}

		while (!turretcamera) 
		{ 
		[sp, turretcamera] = A_SpawnItemEx("SecurityCamera", -2.5 * radius, 0, treads.height + 128, 0, 0, 0, 0, SXF_TRANSFERPITCH | SXF_TRANSFERROLL | SXF_TRANSFERSCALE); 
		}
		
		turretcamera.master = self;
		
		treads.master = self;
		treads.bSolid = false;
		treads.Species = Species;		

		Super.PostBeginPlay();
	}
	
	override void Tick()
	{
		Super.Tick();

		bool chasecam = player.cheats & CF_CHASECAM;

		/*
		if (health == Default.Health && US_Sherman(treads).savedhealth)
		{
			A_SetHealth(US_Sherman(treads).savedhealth);
			US_Sherman(treads).savedhealth = 0;
		}
		*/

		if (!turret) // Since turret is spawned by treads actor, check for it here since it'll be spawned after PostBeginPlay is called
		{
			if (Tank_Component.treads)
			{
				turret = Tank_Component.treads.turret;

				if (turret)
				{
					turret.master = self;
					turret.angle = angle;
					turret.bSolid = false;

					bool sp;
					while (!povcamera) { [sp, povcamera] = turret.A_SpawnItemEx("SecurityCamera", 0, 0, 0, 0, 0, 0, 0, SXF_TRANSFERPITCH | SXF_TRANSFERROLL | SXF_TRANSFERSCALE); }
					povcamera.master = self;
				}
			}
		}

		if (Level.time % (35 * 5) == 0) { ForcedHealthBar = GetClosestForcedHealthBar(); } // Only run this check occasionally

		if (player && turretcamera && treads && turret && povcamera)
		{
			double zoffset = VehicleBase.SetPitchRoll(treads);
			double newz = pos.z - zoffset > GetZAt(0, 0) + MaxDropoffHeight ? pos.z - zoffset : GetZAt(0, 0);
			treads.SetOrigin((pos.xy, newz), true);

			double delta = deltaangle(treads.angle, turret.angle);


			Player.MinPitch = treads.pitch * cos(delta) - 80;
			Player.MaxPitch = treads.pitch * cos(delta) + 80;

			turret.SetOrigin(treads.pos, true);
			//turret.SetOrigin(treads.pos + (RotateVector((treads.radius * sin(treads.pitch), -treads.radius * sin(treads.roll)), treads.angle), treads.height * cos(treads.roll)), true);

			turret.pitch = treads.roll * sin(-delta) + treads.pitch * cos(delta);
			turret.roll = treads.roll * cos(-delta) + treads.pitch * sin(delta);

			if (turret.angle != angle)
			{
			 	turret.angle = !chasecam ? angle : clamp(angle, turret.angle - 1.5, turret.angle + 1.5);
				A_StartSound("MACHINE_LOOP_3", 30, CHANF_NOSTOP, 0.5);
			}
			else
			{
				A_StopSound(30);
			}

			// Force pitch clamping
			if (turret.pitch + pitch >= player.MaxPitch || turret.pitch + pitch <= player.MinPitch)
			{
				player.cmd.pitch = 0;
			}

			if (!gun) { gun = Tank_Turret(turret).gun; }

			if (gun)
			{
				DoTrace(gun, turret.angle, 2048, turret.pitch + pitch, 0, 0, hittracer);

				CrosshairPos = hittracer.Results.HitPos;
				CrosshairActor = hittracer.Results.HitActor;
				CrosshairDist = hittracer.Results.Distance;

				gun.pitch = turret.pitch + pitch;
				gun.roll = turret.roll;
			}

	
		}
		else
		{
			player.camera = player.mo;
		}

	}

	void DoTrace(Actor origin, double angle, double dist, double pitch, int flags, double zoffset, BoAFindHitPointTracer thistracer)
	{
		if (!origin) { origin = self; }

		thistracer.skipspecies = origin.species;
		thistracer.skipactor = origin;
		Vector3 tracedir = (cos(angle) * cos(pitch), sin(angle) * cos(pitch), -sin(pitch));
		thistracer.Trace(origin.pos + (0, 0, zoffset), origin.CurSector, tracedir, dist, 0);
	}	
	
	Actor GetClosestForcedHealthBar()
	{
		ThinkerIterator Finder = ThinkerIterator.Create("MT_Actor", Thinker.STAT_DEFAULT - 3);
		//ThinkerIterator Finder = ThinkerIterator.Create("Base", Thinker.STAT_DEFAULT - 3);
		//Base it;
		MT_Actor it;
		Actor mo;

		/*
		while ( it = Base(Finder.Next()) )
		{
			if (!it.user_DrawHealthBar == True) { continue; } // Only process actors with the AlwaysDrawHealthBar flag set
			if (
				it.health <= 0 ||
				!it.bShootable ||
				it.bDormant
			) { continue; }
			if (mo && Distance3D(it) > Distance3D(mo)) { continue; } // Only draw health bar for the closest one

			mo = it;
		}
		*/

		return mo;
	}	
	
	
}

Class MT_PlayerTank : MT_BaseTank
{
Default
{
MT_BaseTank.Chassis "MT_BaseChassis";
//MT_BaseTank.Tank_Component "MT_Tank";
//MT_BaseTank.Tank_Turret "MT_TankTurret";
player.DisplayName "BASE TANK";
player.viewheight 25;
player.attackzoffset 13;
player.forwardmove 0.85;
player.sidemove 0;
player.jumpz 0;
player.face "TKF";
player.maxhealth 1600;
health 1600;
Speed 0.85;
Species "TankPlayer";
Player.SoundClass "mt_vehicle";
MaxStepHeight 24;
Radius 16;
Height 20;
Mass 50000;
PainChance 128;
BloodType "TankBlood", "TankBlood", "TankBlood";
-FLOORCLIP;
+FIXMAPTHINGPOS;
+DONTRIP;
Player.ColorRange 112, 127;
//Internal stuff, very important
Player.StartItem "MT_ClassToken"              ,1;
Player.StartItem "MHTA1_Token"                ,1;
Player.StartItem "MTU_SupplyBox_2"            ,1;
Player.StartItem "MT_Subgun_Slot"             ,1;
Player.StartItem "MT_AmmoSwitcher"            ,1;
Player.StartItem "MT_AmmoSwitcher_Reverse"    ,1;
Player.StartItem "MT_SubgunSwitcher"          ,1;
Player.Startitem "MT_SubgunSwitcher_Reverse"  ,1;
Player.Startitem "MT_Searchlight"             ,1;
Player.StartItem "MT_Nightvision_MK1"         ,1;
Player.StartItem "MT_ChaseCamera_MK1"         ,1;
Player.StartItem "MT_PeriscopeItem"           ,1;
//Lockers
//Weapons
Player.StartItem "MT_105mmCannon"           ,1;
Player.StartItem "Multi_Purpose_Device"       ,1;
//Ammo
Player.Startitem "MT_75x500mmHE"                ,20;
Player.Startitem "MT_75x500mmAP"                ,40;
Player.Startitem "A_7u62x54mmR"                 ,2000;
//Items
//Player.startitem "Item_GrenadePod_Smoke"        ,8
Player.startitem "Item_GrenadePod_SSS"          ,1;
Player.startitem "Item_GrenadePod_Illuminating" ,2;
Player.startitem "MT_Item_GrenadePod_Flare"     ,30;
Player.Startitem "MT_GrenadePod_Explosive"      ,20;
  
//MT Damage types
DamageFactor "PiercingExplosive" ,0.75;
DamageFactor "Piercing"          ,0.8;
DamageFactor "Frag"              ,0.05;
DamageFactor "Bullet"            ,0.15;
DamageFactor "Acid"              ,0.5;
DamageFactor "Chemical"          ,0.5;
DamageFactor "Build"             ,0;
//Other Damage types
DamageFactor "Normal"            ,0.8;
DamageFactor "Extreme"           ,0.8;
DamageFactor "Drowning"          ,0.0;
DamageFactor "Falling"           ,0.1;
DamageFactor "Ice"               ,0.2;
DamageFactor "Fire"              ,0.1;
Damagefactor "stomp"             ,0;
DamageFactor "Energy"            ,0.85;
DamageFactor "Radiation"         ,0.0;
DamageFactor "Nuclear"           ,0.9;
DamageFactor "Explosive"         ,0.25;
DamageFactor "Buckshot"          ,0;
DamageFactor "Reclaim"           ,0.9;
DamageFactor "Poison"            ,0;
DamageFactor "PoisonCloud"       ,0;
DamageFactor "Electric"          ,0.75;
}

States
{
Pain:
	"####" A 0;
	"####" A 1 A_Pain;
	Goto Spawn;

Spawn:
	TNK1 A 0;
	TNK1 A 1;
	loop;
}
	
}